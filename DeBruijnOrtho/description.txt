Программа организована как множество задач (процессов) обработки, расположенных на разных компьютерах. Одна из запускаемых задач называется «мастером», остальные называются клиентами или исполнителями. Технически, запускается один и тот же код (программа), но на соответствующих компьютерах и с соответствующими параметрами. По параметрам, программа определяет запущена ли она как мастер или как исполнитель. 
Сначала запускается мастер, ему никого ждать не надо, он сам ждет, когда с ним свяжутся. Исполнителю дается IP-адрес мастера и он устанавливает связь с ним. Связь между мастером и исполнителем работает отдельными командами, посылаемыми мастером. То есть, мастер посылает 1 байт – это команда , потом он посылает фактические значения аргументов команды и ждет результатов. Принимает результаты и на этом цикл команды заканчивается и исполнитель ждет следующую команду. Аргументов и результатов может не быть, но если они запланированы, то они обязаны появиться и в нужном формате.  

Все общение производится в бинарном виде средствами BinaryWriter и BinaryReader. Посылаются любые примитивные типы (байт, целые разных размеров, строки и т.д.). Последовательность посылается посылкой двойного целого с числом элементов и потом подряд идут элементы последовательности. Запись - посылаются подряд идущими элементами записи. В общем - как в Поляре. В дальнейшем предполагается внедрить типовую систему Поляра, это позволит усилить контроль за коммуникациями. 

Обработка данных выполняется на мастере. На мастере выполняются преобразования, требующие поэлементной потоковой обработки  и на мастере организуются вычисления, требующие привлечения исполнителей. Исходными данными является набор ридов, задаваемый в тектовом виде во входном файле и расположенный на мастере. 

Main3. Первый этап - преобразование ридов в бинарную форму. Это потоковая обработка, когда последовательность строк ридов преобразуется в последовательность слов с заданным окном сканирования. Окно - это диапазон задаваемой длины n выборки последовательности символов. Для строки рида S первое слово будет S[0], ... S[n-1], второе - S[1], ... S[n] и так далее. Слова кодируются в двойные целые (UInt64) каждый символ - 2 разряда, от младших разрядов к старшим. Соответствие символа 2-битному коду следующее: A-0, C-1, G-2, T-3. Пока это ограничивает размер окна в 32 символа. В дальнейшем, предполагается перейти к формату набора байтов. Таким образом результатом первого этапа обработки яввляется последовательность посделовательностей кодированных слов. Полученный массив также респологается на мастере. В принципе, получаемы массив - довольно большой. Для набора из 500 тыс. ридов, занимающего 49 мб получается файл размером 319 мб. Для задачи в 1000 раз большей, это уже будет представлять проблему. 

Main44. Следующий этап - перевод бинарных ридов в кодированные. Кодированные риды - это те же наборы слов, но закодированные целочисленным кодом. Кодирование - взаимно-однозначное, т.е. по слову однозначно определяется код, по коду - слово. Первое соответствие после второго этапа не сохраняется. Второе - сохраняется. Главное, что кодирование обеспечивает то, что 2 разных слова имеют разные коды и 2 одинаковых - одинаковые. Эффективное кодирование требует довольно много оперативной памяти, напр. для 500 тыс. ридов может потребоваться около 2 Гб. ОЗУ. Применены 2 приема для снижения нагрузки на память. Во-первых, кодирование выполняется в несколько проходов, во вторых - с привлечением исполнителей. 

Основная операция, применяемая на этой стадии: IEnumerable<int> GetSetNodes(IEnumerable<UInt64> bwords). В ней поток бинарных слов преобразуется в поток их кодов с одновременным пополнением хеш-таблицы. На каждом из проходов преобразуется в коды лишь часть слов, соответственно объем хеш-таблицы уменьшен. Причем по завершению прохода, мы можем уничтожить таблицу имен потому что в оставшейся части таких слов не остается. Многопроходный подход "конвертирует" дополнительное время на обработку в уменьшение расхода оперативной памяти. Использование исполнителей основывается на том, что в каждом исполнителе накапливается набор слов, обладающих некоторыми свойствами типа word ^ (n-1) == номер секции (исполнителя). Соотвественно, в указанном методе GetSetNodes набор слов разбивается по секциям и выполняется обращение к этим секциям, а полученные результы сливаются.  В результате данного этапа формируется последовательность (для кластерного варианта - множество последовательностей) узлов, в которой номер элемента последовательности является кодом слова. Соответственно, на этом этапе, слова превращаются в узлы.  

Main51. Другая часть графа - ребра, реализуется (в упрощенном представлении) через ссылки (коды узлов) "вперед" и "назад", в структуре узла CNode. Это делается через модификацию списка узлов при сканировании файла кодированных ридов. 





      
